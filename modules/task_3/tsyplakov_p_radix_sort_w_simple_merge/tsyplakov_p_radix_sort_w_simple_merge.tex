\documentclass{report}

\usepackage[warn]{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage{tempora}
\usepackage[12pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2.3cm,bottom=2.3cm,left=2.5cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{listings}
\lstset{language=C++,
        basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{red}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}
\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}
\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}
\begin{center}
Институт информационных технологий, математики и механики
\end{center}
\vspace{4em}
\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Поразрядная сортировка для вещественных чисел (тип double) 
с простым слиянием.»} \\
\end{center}
\vspace{4em}
\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381906-3 \\ Цыплаков П. М. \\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}
\begin{center} Нижний Новгород \\ 2021 \end{center}
\end{titlepage}
\setcounter{page}{2}
\tableofcontents
\newpage
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par 
Алгоритм поразрядной сортировки заключается в поразрядном упорядочивании элементов массива. 
На каждой итерации алгоритм обрабатывает только один разряд. Обработка идет в сторону большего разряда. После окончания работы над высшим разрядом алгоритм заканчивает свою работу.
Реализация параллельного алгоритма подразумевает произведение вычислений по отдельности. Алгоритм сортировки простым слиянием будет использован для сбора обработанных фрагментов массива и их упорядоченного сохранения.
Лабораторная работа направлена на реализацию последовательного и параллельного алгоритма поразрядной сортировки со сбором обработанных данных, с использованием алгоритма простого слияния.
Данный алгоритм реализован в три этапа:
\begin{enumerate}
\item Разбиение массива на части.
\item Сортировка частей массива.
\item Упорядоченое слияние частей массива в один простым слиянием.
\end{enumerate}
\newpage
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\par Задача данной лабораторной работы — реализация последовательного и параллельного алгоритма поразрядной сортировки. При реализации параллельного алгоритма необходимо использовать "простое слияние" для сбора частей массива.
Оценка эффективности алгоритмов будет произведена при помощи модуля Google Test. Выводы будут производиться на основе времени, затраченного на сортировку идентичного массива.
\newpage
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\par Алгоритм заключается в последовательной сортировке элементов по разрядам — от низшего к высшему разряду. Выравнивание элементов производится по MSD (most significant digit) сортировке.

Сравнение осуществляется поразрядно: в первую очередь элементы сравниваются и сортируются по значению наименьшего разряда, и далее пошагово к высшему.

Пошагово:
\begin{enumerate} 
\item Создается вектор для хранения упорядоченных элементов. В ходе алгоритма он также используется как буфер между итерациями.
\item Производятся вычисления максимального количества разрядов среди элементов заданного вектора.
\item Цикл for, количество итераций которого равно максимальному количеству разрядов среди элементов в массиве.
\item Создается вектор из 10 очередей, где будут храниться элементы соответственно значению в разряде элемента, по которому производится сортировка на данной итерации.
\item Вложенный цикл for, в котором заполняется вектор очередей: в очередь n мы помещаем методом push элемент, значение разряда которого равно n.
\item Вложенный цикл for, в котором опустошается вектор очередей. Его элементы, начиная с 0 очереди, сохраняются в вектор, созданный на шаге 1.
\end{enumerate}
Алгоритм простого слияния заключается в сравнивании элементов двух упорядоченных векторов, начиная с наименьшего (наибольшего), заканчивая наибольшим (наименьшим). Если сравнение идет с наименьшего конца вектора, то в результирующий вектор будет помещен меньший из двух сравниваемых элементов векторов. Цикл идёт до того момента, пока один из векторов не будет опустошен.
После этого элементы непустого вектора будут упорядоченно добавлены в конец результирующего.
\newpage
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
\par 
Параллельная реализация начинается с рассылки при помощи метода MPI\_Scatter одинакового количества данных каждому из имеющихся процессов. Каждый процесс получает отправленные данные и обрабатывает их последовательным алгоритмом поразрядной сортировки.
Возврат идентичного объема данных производится методом MPi\_Send. Корневой процесс получает отправленные процессами части массива методом MPI\_Recv. 
\newpage
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Программа состоит из заголовочного файла radix\_sort\_w\_merge\_sort.h и двух файлов .cpp radix\_sort\_w\_merge\_sort.cpp и main.cpp. Заголовочный файл содержит прототипы функций для последовательного и параллельного алгоритмов, а также для генерации вектора. В файле radix\_sort\_w\_merge\_sort.cpp реализованы функции последовательного, параллельного и вспомогательных функций. Файл main.cpp содержит тесты для оценки работоспособности и эффективности алгоритмов.
\begin{enumerate}
\item std::vector<double> getRandomVector(int sz) — возвращает случайный вектор размера size.
\item std::vector<double> ParallelRadixSort(const std::vector<double>\& global\_vec, const int count\_size\_vector) — параллельная поразрядная сортировка с простым слиянием вектора global\_vec размера count\_size\_vector
\item std::vector<double> SequentialRadixSort(const std::vector<double>\& vec) — последовательная поразрядная сортировка вектора vec
\item std::vector<double> simpleMerge(const std::vector<double>\& first\_vec, const std::vector<double>\& second\_vec) — алгоритм простого слияния для двух векторов
\item int calcValueByRank(const double\& value, int rank) — возвращает значение разряда rank элемента value
\item int maxRank(const std::vector<double>\& vect) — вычисляет максимальный разряд среди элементов вектора vect

\end{enumerate}
\newpage
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности был реализован набор тестов на базе модуля для тестирования Google Testing Framework для C++.
Тесты проверяют корректность и эффективность работы последовательного и параллельного алгоритмов сортировки на массивах различного размера.
Проведенные тесты выдали результат PASSED на всех пяти запрограммированных наборах данных.
\newpage
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Тесты проводились на ПК с следующей конфигурацией:
\begin{itemize}
\item Процессор: Intel Core i5-10210U CPU 1.60GHz
\item Оперативная память: 24 ГБ;
\item Операционная система: Windows 10;
\item Версия Visual Studio: 2019.
\end{itemize}
На таблице ниже приведены результаты тестов на различных числах процессов и различных размерах массивов.
\begin{table}[!h]
\begin{tabular}{| p{2cm} | p{2cm} | p{3cm} | p{3cm} | p{3cm} |}
\hline
Количество процессов & Размер массива & Время работы последовательного алгоритма & Время работы параллельного алгоритма & Эффективность  \\[5pt]
\hline
1 &   1000    & 0.0456578        & 0.0471442     & 0.968471       \\
1  & 2000     & 0.0264628        & 0.0264628     & 0.999214       \\
4    & 20000    & 0.211656        & 0.0724585     & 2.92108       \\
4   &  50000   & 0.615547        & 0.244431     & 2.51828      \\
8    & 20000   & 0.216661        & 0.069612     & 3.11241       \\
8   &  50000   & 0.557914        & 0.132608     & 4.20724       \\
\hline
\end{tabular}
\end{table}
\newpage
\section*{Выводы по результатам экспериментов}
\addcontentsline{toc}{section}{Выводы по результатам экспериментов}
По результатам экспериментов можно сделать вывод, что алгоритм параллельной поразрядной сортировки с простым слиянием работает более эффективно на массивах элементов большего размера. Также на крупных массивах эффективность параллельной реализации поразрядной сортировки выше последовательной более чем в 4 раза.
\newpage
% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В ходе работы были реализованы последовательный и параллельный алгоритм сортировки. Во втором случае был имплементирован алгоритм простого слияния для сбора частей массива.
Была произведена оценка эффективности алгоритмов и сделаны выводы по полученным результатам.
\newpage
\section*{Источники}
\addcontentsline{toc}{section}{Источники}
\begin{enumerate}
\item Сайт Algolab - Электронный ресурс. URL: http://algolab.valemak.com/radix
\item Programiz - Электронный ресурс. URL: https://www.programiz.com/dsa/radix-sort
\item Википедия - Электронный ресурс. URL: https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0 
\item Geeks For Geeks - Электронный ресурс. URL: https://www.geeksforgeeks.org/radix-sort/
\item CodeLab - Электронный ресурс. URL: https://codelab.ru/task/radix\_sort-basic/
\end{enumerate} 
\newpage
\end{document}