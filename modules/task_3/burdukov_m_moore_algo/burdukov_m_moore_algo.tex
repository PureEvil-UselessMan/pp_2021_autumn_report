\documentclass{report}

\usepackage[warn]{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage{tempora}
\usepackage[12pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{listings}
\lstset{language=C++,
        basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{red}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Реализация алгоритма Мура с помощью MPI»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнила:} \\ студент группы 381908-1 \\ Бурдуков М.И.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2021 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par Алгоритм Мура предназначен для нахождение в графах ,без циклов отрицательной длины, кратчайшего пути между вершинами S и T
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\par Реализовать паралльный алгоритм Мура на технологии MPI
\newpage

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\par 
Алгоритм является модификаций алгоритма Дейктры, но в отличии от него не требует
отсутствия рёбер отрицательного веса.
Для его реализации необходимо:
\par 1. Взвешенный граф в котором отсутствуют циклы отрицательного веса (G(V,E)).
\par 2. Стартовая и финишная вершина (S,T).
\par 3. Очередь вершин(q).
\par 4. Массив текущих расстояний от вершины S до всех других вершин графа (d).
\par 5. Массив вершин ,которые уже были в q(was)
\par Последовательность действий
\par 1. Добавление в q стартовой вершины и инициализация d значением INF.
\par 2. Изменение d[S] на 0 и was[S] на true.
\par 3. Начало итераций.
\par 4. Берем первую вершину(current) из очереди и удаляем ее из нее , если очередь
\par пустая то выходим из алгоритма.
\par 5. Итерируемся по всем ребрам текущей вершины (to).
\par 6. Если ребро является релаксирующим то d[to] = d[current]+ вес ребра:
\par a. Если was[to] не равна False , то добаляем в начало q.
\par b. Если was[to] равно False, то добавляем в конец.
\par 7. was[to] приравниваем к True.
\par 8. Перейти к 4 шагу.
\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
\par
Для реализации данного алгоритма на MPI необходимо все процессы разделить на два
класса:
a. Главный рабочий(main worker).
b. Остальные процессы(side workers).
Main worker будет заниматься разделением работы между процессами, так же он будет
заниматься всеми шагами в одиночку кроме 5-7 шага.
\par
Для корректной работы остальным процессам необходимо отправить массив вершин,
которые ему нужно будет обработать, текущее расстояние до вершины current и ребра для
этих вершин. Всю работу он разделяет на блоки равные кол-во вершин/кол-во процессов.
Каждому side worker он выделяет работу равную этому блоку.
В конечном итоге он принимает только список вершин , которые нужно релаксировать и
обрабатывает их.
\par
У side workers имеется два состояния:
\par 1. Ожидание данных от главного процесса.
\par 2. Обработка данных для главного процесса.
Таким образом, они занимаются только обработкой данных , которые прислал главный
процесс: ищут среди выделенных ему вершин , те до которых расстояние можно
уменьшить, и отправляют готовый массив таких вершин.
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Вычислительные эксперименты для оценки эффективности работы параллельного алгоритма проводились на ПК со следующими характеристиками:
\begin{table}[!h]
\caption{Результаты вычислительных экспериментов}
\centering
\begin{tabular}{| p{2cm} | p{3cm} | p{4cm} | p{2cm} |}
\hline
Количество процессов & Время работы последовательного алгоритма (в секундах) на 4 графах(3,4,128,256 вершин)\\[5pt]
\hline
1        & 8.2181          \\
2        & 6.7378        \\
4        & 5.8261         \\
8        & 5.0037        \\
16        & 4.9031        \\
\hline
\end{tabular}
\end{table}

\section*{Заключение и описание архитектурных решений}
\addcontentsline{toc}{section}{Заключение и описание архитектурных решений}

\par В заключение можно сказать , что сам алгоритм плохо параллелится и в данный момент не
актуален , из-за существование более быстрых аналогов( алгоритм Дейкстры , построенный
на взвешенном дереве). Плохая степень параллелизма заключается в том , что данные
слишком зависимы друг от друга и что MPI не поддерживает создание share объектов после
создания пула рабочих процессов.
\par Тут можно возразить и сказать , что можно создавать пул процессов после того , как
созданы общая очередь и массив посещенных вершин. Но работа с ними очень сложна
из-за отсутствия необходимых примитивов синхронизации(mutex и т.д.).Также такой вариант
плохо ложится на данную задачу из-за того , что пересылка данных будет не медленнее ,
чем MPI INIT, из-за того что сам алгоритм предназначен для маленьких графов (не более
1000 вершин), большие графы будет сложнее обрабатывать из-за асимптотической
сложности алгоритма.

\end{document}